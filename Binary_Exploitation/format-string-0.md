# Let's make some patties, shall we!

While solving a CTF related to a c file, what's my favourite snack you ask?

Ofc it is the buffer size. The easiest, simplest, and a no-brainer way to solve a task.

The first thing I do when I see a c file is to exploit the buffer size. It's like a ritual now.

My first step is to enter loads of data to see if it works...

So let's check it out

```
#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];
```

Here is our start...

```
 char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
```

and here is our BINGO!

I mean that there is no limit added to the %s. MUAHAHAHAHAHAHA.

What are we waiting for? Let's spam!

![Pic1](C:\Users\ElaYTurbo\Desktop\TurboFile\Projects\Crypto\ss8.png)

There you go...

**picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}**

But what was the minimum amount of data we had to enter?

Just more than the buffsize, so 33. but but but, This will only lead to exit.
There's another line which uses count > 2* BUFFSIZE,

```
 char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
```

so we need to enter 65 characters to 
correctly give the flag.
